filter(date >= "2020-01-01") %>% autoplot(df_demanda%>%
filter(date >= "2020-01-01"))
# SARIMA ---------------------------------------------------------------------------------------------------------------------------------
# Ajuste 1
# Probamos ajustando un modelo con componentes de
fit <- df_demanda_train %>%
model(arima = ARIMA(energy ~ pdq(0,0,2) + PDQ(0,0,2))) #pdq(0,0,2) + PDQ(0,0,2)
report(fit)
gg_arma(fit)
# Si mostramos los residuos vemos que aún no es un ruido blanco, aparecen picos que habría que evitar.
# Si observamos el gráfico ACF vemos que aún hay picos en retardos 14, 21, 28.. que hay que ajustar.
# Si observamos el gráfico PACF vemos que hay retardos en los mismos retardos con picos prácticamente.
fit %>% my_tsresiduals()
# Forecast
forecast_1 =  forecast(fit, h=10)
# PLot forecast
#forecast %>% autoplot(df_demanda_train)
forecast_1 %>% autoplot(df_demanda%>% filter(date >= "2020-01-01"))
# Residuals
#mape(df_demanda_test$energy, forecast_1$energy)
accuracy(forecast_1$energy, df_demanda_test$energy)
# Ajuste 2
# Probamos ajustando valores para modelar las componentes estacionales.
fit2 <- df_demanda_train %>%
model(arima = ARIMA(energy ~ pdq(1,0,2) + PDQ(0,2,3))) #pdq(0,0,2) + PDQ(0,0,2)
report(fit2)
gg_arma(fit2)
fit2 %>% my_tsresiduals()
# Forecast
forecast_2 =  forecast(fit2, h=10)
# PLot forecast
#forecast %>% autoplot(df_demanda_train)
forecast_2 %>% autoplot(df_demanda%>% filter(date >= "2020-01-01"))
# Residuals
mape(df_demanda_test$energy, forecast_2$energy)
accuracy(forecast_2$energy, df_demanda_test$energy)
mape(forecast_2$energy, df_demanda_test$energy)
# Test: febrero 2020
df_demanda_test = df_demanda[(df_demanda$date >= '2020-02-01') & (df_demanda$date <= '2020-02-10'),] #2020-03-01
df_demanda = df_demanda[(df_demanda$date < '2020-02-10'),] ##2020-03-01
# Transform into a tibble object
df_demanda_train <- df_demanda_train %>%
as_tsibble(index = date) #key = c(energy), index = datetime
df_demanda_test <- df_demanda_test %>%
as_tsibble(index = date) #key = c(energy), index = datetime# Descomposición clásica
df_demanda <- df_demanda %>%
as_tsibble(index = date) #key = c(energy), index = datetime# Descomposición clásica
# plot series temporales
df_demanda_train %>%
autoplot(energy) +
labs(title = "", subtitle = "")
#aditivo
df_demanda_train %>%
model(classical_decomposition(energy, type = "additive")) %>%
components() %>%
autoplot() + xlab(" ") +
ggtitle(" ")
demanda_decomposed = classical_decomposition(energy, type = "additive")
#multiplicativo
df_demanda_train %>%
model(classical_decomposition(energy, type = "multiplicative")) %>%
components() %>%
autoplot() + xlab(" ") +
ggtitle(" ")
# Diferenciación
# Se observa que tras la diferenciación la serie pierde la tendencia, siendo claramente estacionaria en media.
# yt = xt - x(t-1)
df_demanda_train %>% autoplot( difference(energy)) +
xlab("  ") + ylab(" ") +
ggtitle("  ")
# Una forma de determinar más objetivamente si es necesario diferenciar es utilizar una prueba de raíz unitaria.
# En este contraste, la hipótesis nula es que los datos son estacionarios, y buscamos pruebas de que la hipótesis nula es falsa. En consecuencia, pequeños p-valores (por ejemplo, menos de 0,05) sugieren que es necesario diferenciar.
df_demanda_train %>%
features(energy, unitroot_kpss)
df_demanda_train %>%
mutate(diff_close = difference(energy)) %>%
features(diff_close, unitroot_kpss)
#Comprobar si existen autocorrelaciones significaticas:
df_demanda_train %>%
mutate(diff_close = difference(energy)) %>%
features(diff_close, ljung_box, lag = 10)
# el pico significativo en el retardo 7 del ACF sugiere un componente MA(1) estacional
# Vemos que hay unos picos estacionales cada 7 días -> componente estacional.
# El pico significativo en el retardo 1 del ACF sugiere por lo menos una componente MA(2) no estacional
df_demanda_train %>% ACF(energy) %>% autoplot()
# Mejor observar el ACF y PACF sin la diferenciación primero
#Se continúa observando picos estacionales a los 7 días
# Sigue un comportamiento parecido al gráfico anterior: El pico significativo en el retardo 1 del ACF sugiere por lo menos una componente MA(2) no estacional
#un pico en la primera componente, sugiriendo una componente autoregresiva por lo menos de valor 1.
df_demanda_train %>% PACF(energy) %>% autoplot()
df_demanda1_diff <- difference(df_demanda_train$energy, 7)
# SARIMA ---------------------------------------------------------------------------------------------------------------------------------
# Ajuste 1
# Probamos ajustando un modelo con componentes de
fit <- df_demanda_train %>%
model(arima = ARIMA(energy ~ pdq(0,0,2) + PDQ(0,0,2))) #pdq(0,0,2) + PDQ(0,0,2)
report(fit)
gg_arma(fit)
# Si mostramos los residuos vemos que aún no es un ruido blanco, aparecen picos que habría que evitar.
# Si observamos el gráfico ACF vemos que aún hay picos en retardos 14, 21, 28.. que hay que ajustar.
# Si observamos el gráfico PACF vemos que hay retardos en los mismos retardos con picos prácticamente.
fit %>% my_tsresiduals()
# Forecast
forecast_1 =  forecast(fit, h=10)
# PLot forecast
#forecast %>% autoplot(df_demanda_train)
forecast_1 %>% autoplot(df_demanda%>% filter(date >= "2020-01-01"))
# Residuals
#mape(df_demanda_test$energy, forecast_1$energy)
accuracy(forecast_1$energy, df_demanda_test$energy)
# Ajuste 2
# Probamos ajustando valores para modelar las componentes estacionales.
fit2 <- df_demanda_train %>%
model(arima = ARIMA(energy ~ pdq(1,0,2) + PDQ(0,2,3))) #pdq(0,0,2) + PDQ(0,0,2)
report(fit2)
gg_arma(fit2)
fit2 %>% my_tsresiduals()
# Residuals
mape(df_demanda_test$energy, forecast_1$energy)
accuracy(forecast_1$energy, df_demanda_test$energy)
# Test: febrero 2020
df_demanda_test = df_demanda[(df_demanda$date >= '2020-02-01') & (df_demanda$date <= '2020-02-10'),] #2020-03-01
# Transform into a tibble object
df_demanda_train <- df_demanda_train %>%
as_tsibble(index = date) #key = c(energy), index = datetime
df_demanda_test <- df_demanda_test %>%
as_tsibble(index = date) #key = c(energy), index = datetime# Descomposición clásica
df_demanda <- df_demanda %>%
as_tsibble(index = date) #key = c(energy), index = datetime# Descomposición clásica
# SARIMA ---------------------------------------------------------------------------------------------------------------------------------
# Ajuste 1
# Probamos ajustando un modelo con componentes de
fit <- df_demanda_train %>%
model(arima = ARIMA(energy ~ pdq(0,0,2) + PDQ(0,0,2))) #pdq(0,0,2) + PDQ(0,0,2)
report(fit)
gg_arma(fit)
# Si mostramos los residuos vemos que aún no es un ruido blanco, aparecen picos que habría que evitar.
# Si observamos el gráfico ACF vemos que aún hay picos en retardos 14, 21, 28.. que hay que ajustar.
# Si observamos el gráfico PACF vemos que hay retardos en los mismos retardos con picos prácticamente.
fit %>% my_tsresiduals()
# Forecast
forecast_1 =  forecast(fit, h=10)
# PLot forecast
#forecast %>% autoplot(df_demanda_train)
forecast_1 %>% autoplot(df_demanda%>% filter(date >= "2020-01-01"))
# Residuals
mape(df_demanda_test$energy, forecast_1$energy)
accuracy(forecast_1$energy, df_demanda_test$energy)
accuracy(forecast_1, df_demanda_test)
View(forecast_1)
View(df_demanda_test)
# Test: febrero 2020
df_demanda_test = df_demanda[(df_demanda$date >= '2020-02-01') & (df_demanda$date <= '2020-02-10'),] #2020-03-01
View(df_demanda_test)
# Test: febrero 2020
df_demanda_test = df_demanda[(df_demanda$date > '2020-01-31') & (df_demanda$date <= '2020-02-10'),] #2020-03-01
View(df_demanda_test)
library(tidyverse)
library(tsibble)
library(fable)
library(feasts)
library(tsibbledata)
library(normtest)
library(lmtest)
library(forecast)
setwd("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2")
df_ree <- read.csv("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2/ree.csv")
#df_ree$datetime <- strptime(x = as.character(df_ree$datetime),
#                                format = "%d/%m/%Y %H:%M")
df_ree$id <- NULL
df_ree$date = substr(df_ree$datetime,1,10)
mape <- function(actual,pred){
mape <- mean(abs((actual - pred)/actual))*100
return (mape)
}
View(df_ree)
#check null values
(cols_withNa <- apply(df_ree, 2, function(x) sum(is.na(x))))
df_demanda <- df_ree %>%
filter(subcategory == "Demanda en b.c.")
View(df_demanda)
df_demanda$datetime <- as.POSIXct(df_demanda$datetime)
df_demanda$date <- as.Date(df_demanda$datetime, format="%d/%m/%Y")
View(df_demanda)
df_demanda$date <- as.Date(df_demanda$datetime)
View(df_demanda)
setwd("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2")
df_ree <- read.csv("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2/ree.csv")
#df_ree$datetime <- strptime(x = as.character(df_ree$datetime),
#                                format = "%d/%m/%Y %H:%M")
df_ree$id <- NULL
df_ree$date = substr(df_ree$datetime,1,10)
mape <- function(actual,pred){
mape <- mean(abs((actual - pred)/actual))*100
return (mape)
}
#check null values
(cols_withNa <- apply(df_ree, 2, function(x) sum(is.na(x))))
df_demanda <- df_ree %>%
filter(subcategory == "Demanda en b.c.")
df_demanda$datetime <- as.POSIXct(df_demanda$datetime)
df_demanda$date <- as.Date(df_demanda$datetime)
View(df_demanda)
setwd("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2")
df_ree <- read.csv("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2/ree.csv")
#df_ree$datetime <- strptime(x = as.character(df_ree$datetime),
#                                format = "%d/%m/%Y %H:%M")
df_ree$id <- NULL
df_ree$date = substr(df_ree$datetime,1,10)
mape <- function(actual,pred){
mape <- mean(abs((actual - pred)/actual))*100
return (mape)
}
#check null values
(cols_withNa <- apply(df_ree, 2, function(x) sum(is.na(x))))
df_demanda <- df_ree %>%
filter(subcategory == "Demanda en b.c.")
df_demanda$datetime <- as.POSIXct(df_demanda$datetime)
View(df_demanda)
# dividir TRAIN - TEST
# Train: enero 2018- enero 2020
df_demanda_train = df_demanda[df_demanda$date < '2020-02-01',]
# Test: febrero 2020
df_demanda_test = df_demanda[(df_demanda$date > '2020-01-31') & (df_demanda$date <= '2020-02-10'),] #2020-03-01
df_demanda = df_demanda[(df_demanda$date < '2020-02-10'),] ##2020-03-01
# Transform into a tibble object
df_demanda_train <- df_demanda_train %>%
as_tsibble(index = date) #key = c(energy), index = datetime
df_demanda_test <- df_demanda_test %>%
as_tsibble(index = date) #key = c(energy), index = datetime# Descomposición clásica
setwd("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2")
df_ree <- read.csv("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2/ree.csv")
#df_ree$datetime <- strptime(x = as.character(df_ree$datetime),
#                                format = "%d/%m/%Y %H:%M")
df_ree$id <- NULL
df_ree$date = substr(df_ree$datetime,1,10)
mape <- function(actual,pred){
mape <- mean(abs((actual - pred)/actual))*100
return (mape)
}
#check null values
(cols_withNa <- apply(df_ree, 2, function(x) sum(is.na(x))))
df_demanda <- df_ree %>%
filter(subcategory == "Demanda en b.c.")
df_demanda$datetime <- as.POSIXct(df_demanda$datetime)
df_demanda$date <- as.Date(df_demanda$datetime)
df_demanda$date <- as.Date(df_demanda$datetime, format="%d/%m/%Y", origin = "2018-01-01")
setwd("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2")
df_ree <- read.csv("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2/ree.csv")
#df_ree$datetime <- strptime(x = as.character(df_ree$datetime),
#                                format = "%d/%m/%Y %H:%M")
df_ree$id <- NULL
df_ree$date = substr(df_ree$datetime,1,10)
mape <- function(actual,pred){
mape <- mean(abs((actual - pred)/actual))*100
return (mape)
}
#check null values
(cols_withNa <- apply(df_ree, 2, function(x) sum(is.na(x))))
df_demanda <- df_ree %>%
filter(subcategory == "Demanda en b.c.")
df_demanda$datetime <- as.POSIXct(df_demanda$datetime)
df_demanda$date <- as.Date(df_demanda$datetime, format="%d/%m/%Y", origin = "2018-01-01")
df_demanda$datetime <- as.POSIXct(df_demanda$datetime,format="%d/%m/%Y")
setwd("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2")
df_ree <- read.csv("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2/ree.csv")
#df_ree$datetime <- strptime(x = as.character(df_ree$datetime),
#                                format = "%d/%m/%Y %H:%M")
df_ree$id <- NULL
df_ree$date = substr(df_ree$datetime,1,10)
mape <- function(actual,pred){
mape <- mean(abs((actual - pred)/actual))*100
return (mape)
}
#check null values
(cols_withNa <- apply(df_ree, 2, function(x) sum(is.na(x))))
df_demanda <- df_ree %>%
filter(subcategory == "Demanda en b.c.")
df_demanda$datetime <- as.POSIXct(df_demanda$datetime,format="%d/%m/%Y")
df_demanda$date <- as.Date(df_demanda$datetime) #, format="%d/%m/%Y", origin = "2018-01-01"
# dividir TRAIN - TEST
# Train: enero 2018- enero 2020
df_demanda_train = df_demanda[df_demanda$date < '2020-02-01',]
setwd("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2")
df_ree <- read.csv("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2/ree.csv")
#df_ree$datetime <- strptime(x = as.character(df_ree$datetime),
#                                format = "%d/%m/%Y %H:%M")
df_ree$id <- NULL
df_ree$date = substr(df_ree$datetime,1,10)
mape <- function(actual,pred){
mape <- mean(abs((actual - pred)/actual))*100
return (mape)
}
#check null values
(cols_withNa <- apply(df_ree, 2, function(x) sum(is.na(x))))
df_demanda <- df_ree %>%
filter(subcategory == "Demanda en b.c.")
df_demanda$datetime <- as.POSIXct(df_demanda$datetime,format="%d/%m/%Y")
# dividir TRAIN - TEST
# Train: enero 2018- enero 2020
df_demanda_train = df_demanda[df_demanda$date < '2020-02-01',]
# Test: febrero 2020
df_demanda_test = df_demanda[(df_demanda$date > '2020-01-31') & (df_demanda$date <= '2020-02-10'),] #2020-03-01
df_demanda = df_demanda[(df_demanda$date < '2020-02-10'),] ##2020-03-01
# Transform into a tibble object
df_demanda_train <- df_demanda_train %>%
as_tsibble(index = date) #key = c(energy), index = datetime
df_demanda$datetime <- as.POSIXct(df_demanda$datetime)
df_demanda$date <- as.Date(df_demanda$datetime) #, format="%d/%m/%Y", origin = "2018-01-01"
library(tidyverse)
library(tsibble)
library(fable)
library(feasts)
library(tsibbledata)
library(normtest)
library(lmtest)
library(forecast)
setwd("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2")
df_ree <- read.csv("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2/ree.csv")
#df_ree$datetime <- strptime(x = as.character(df_ree$datetime),
#                                format = "%d/%m/%Y %H:%M")
df_ree$id <- NULL
df_ree$date = substr(df_ree$datetime,1,10)
mape <- function(actual,pred){
mape <- mean(abs((actual - pred)/actual))*100
return (mape)
}
#check null values
(cols_withNa <- apply(df_ree, 2, function(x) sum(is.na(x))))
df_demanda <- df_ree %>%
filter(subcategory == "Demanda en b.c.")
df_demanda$datetime <- as.POSIXct(df_demanda$datetime)
df_demanda$date <- as.Date(df_demanda$datetime) #, format="%d/%m/%Y", origin = "2018-01-01"
# dividir TRAIN - TEST
# Train: enero 2018- enero 2020
df_demanda_train = df_demanda[df_demanda$date < '2020-02-01',]
setwd("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2")
df_ree <- read.csv("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2/ree.csv")
#df_ree$datetime <- strptime(x = as.character(df_ree$datetime),
#                                format = "%d/%m/%Y %H:%M")
df_ree$id <- NULL
df_ree$date = substr(df_ree$datetime,1,10)
mape <- function(actual,pred){
mape <- mean(abs((actual - pred)/actual))*100
return (mape)
}
#check null values
(cols_withNa <- apply(df_ree, 2, function(x) sum(is.na(x))))
df_demanda <- df_ree %>%
filter(subcategory == "Demanda en b.c.")
df_demanda$datetime <- as.POSIXct(df_demanda$datetime)
df_demanda$date <- format(as.Date(df_demanda$datetime), "%d/%m/%Y")
View(df_demanda)
setwd("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2")
df_ree <- read.csv("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2/ree.csv")
#df_ree$datetime <- strptime(x = as.character(df_ree$datetime),
#                                format = "%d/%m/%Y %H:%M")
df_ree$id <- NULL
df_ree$date = substr(df_ree$datetime,1,10)
mape <- function(actual,pred){
mape <- mean(abs((actual - pred)/actual))*100
return (mape)
}
View(df_ree)
#check null values
(cols_withNa <- apply(df_ree, 2, function(x) sum(is.na(x))))
df_demanda <- df_ree %>%
filter(subcategory == "Demanda en b.c.")
df_demanda$datetime <- as.POSIXct(df_demanda$datetime)
View(df_demanda)
df_demanda$date <- as.Date(df_demanda$datetime) #, format="%d/%m/%Y", origin = "2018-01-01"
setwd("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2")
df_ree <- read.csv("~/Escritorio/MASTER/CUATRI3/MACHINE_LEARNING2/PRACTICA/ML2/ree.csv")
#df_ree$datetime <- strptime(x = as.character(df_ree$datetime),
#                                format = "%d/%m/%Y %H:%M")
df_ree$id <- NULL
df_ree$date = substr(df_ree$datetime,1,10)
mape <- function(actual,pred){
mape <- mean(abs((actual - pred)/actual))*100
return (mape)
}
#check null values
(cols_withNa <- apply(df_ree, 2, function(x) sum(is.na(x))))
df_demanda <- df_ree %>%
filter(subcategory == "Demanda en b.c.")
df_demanda$datetime <- as.POSIXct(df_demanda$datetime)
df_demanda$date <- as.Date(as.character(df_demanda$datetime)) #, format="%d/%m/%Y", origin = "2018-01-01"
# dividir TRAIN - TEST
# Train: enero 2018- enero 2020
df_demanda_train = df_demanda[df_demanda$date < '2020-02-01',]
View(df_demanda)
# Test: febrero 2020
df_demanda_test = df_demanda[(df_demanda$date > '2020-01-31') & (df_demanda$date <= '2020-02-10'),] #2020-03-01
df_demanda = df_demanda[(df_demanda$date < '2020-02-10'),] ##2020-03-01
# Transform into a tibble object
df_demanda_train <- df_demanda_train %>%
as_tsibble(index = date) #key = c(energy), index = datetime
df_demanda_test <- df_demanda_test %>%
as_tsibble(index = date) #key = c(energy), index = datetime# Descomposición clásica
df_demanda <- df_demanda %>%
as_tsibble(index = date) #key = c(energy), index = datetime# Descomposición clásica
# plot series temporales
df_demanda_train %>%
autoplot(energy) +
labs(title = "", subtitle = "")
#aditivo
df_demanda_train %>%
model(classical_decomposition(energy, type = "additive")) %>%
components() %>%
autoplot() + xlab(" ") +
ggtitle(" ")
demanda_decomposed = classical_decomposition(energy, type = "additive")
#multiplicativo
df_demanda_train %>%
model(classical_decomposition(energy, type = "multiplicative")) %>%
components() %>%
autoplot() + xlab(" ") +
ggtitle(" ")
# Diferenciación
# Se observa que tras la diferenciación la serie pierde la tendencia, siendo claramente estacionaria en media.
# yt = xt - x(t-1)
df_demanda_train %>% autoplot( difference(energy)) +
xlab("  ") + ylab(" ") +
ggtitle("  ")
# Una forma de determinar más objetivamente si es necesario diferenciar es utilizar una prueba de raíz unitaria.
# En este contraste, la hipótesis nula es que los datos son estacionarios, y buscamos pruebas de que la hipótesis nula es falsa. En consecuencia, pequeños p-valores (por ejemplo, menos de 0,05) sugieren que es necesario diferenciar.
df_demanda_train %>%
features(energy, unitroot_kpss)
df_demanda_train %>%
mutate(diff_close = difference(energy)) %>%
features(diff_close, unitroot_kpss)
#Comprobar si existen autocorrelaciones significaticas:
df_demanda_train %>%
mutate(diff_close = difference(energy)) %>%
features(diff_close, ljung_box, lag = 10)
# el pico significativo en el retardo 7 del ACF sugiere un componente MA(1) estacional
# Vemos que hay unos picos estacionales cada 7 días -> componente estacional.
# El pico significativo en el retardo 1 del ACF sugiere por lo menos una componente MA(2) no estacional
df_demanda_train %>% ACF(energy) %>% autoplot()
# Mejor observar el ACF y PACF sin la diferenciación primero
#Se continúa observando picos estacionales a los 7 días
# Sigue un comportamiento parecido al gráfico anterior: El pico significativo en el retardo 1 del ACF sugiere por lo menos una componente MA(2) no estacional
#un pico en la primera componente, sugiriendo una componente autoregresiva por lo menos de valor 1.
df_demanda_train %>% PACF(energy) %>% autoplot()
df_demanda1_diff <- difference(df_demanda_train$energy, 7)
# SARIMA ---------------------------------------------------------------------------------------------------------------------------------
# Ajuste 1
# Probamos ajustando un modelo con componentes de
fit <- df_demanda_train %>%
model(arima = ARIMA(energy ~ pdq(0,0,2) + PDQ(0,0,2))) #pdq(0,0,2) + PDQ(0,0,2)
report(fit)
gg_arma(fit)
# Si mostramos los residuos vemos que aún no es un ruido blanco, aparecen picos que habría que evitar.
# Si observamos el gráfico ACF vemos que aún hay picos en retardos 14, 21, 28.. que hay que ajustar.
# Si observamos el gráfico PACF vemos que hay retardos en los mismos retardos con picos prácticamente.
fit %>% my_tsresiduals()
# Forecast
forecast_1 =  forecast(fit, h=10)
# PLot forecast
#forecast %>% autoplot(df_demanda_train)
forecast_1 %>% autoplot(df_demanda%>% filter(date >= "2020-01-01"))
# Residuals
mape(df_demanda_test$energy, forecast_1$energy)
accuracy(forecast_1, df_demanda_test) #$energy
# Ajuste 2
# Probamos ajustando valores para modelar las componentes estacionales.
fit2 <- df_demanda_train %>%
model(arima = ARIMA(energy ~ pdq(1,0,2) + PDQ(0,2,3))) #pdq(0,0,2) + PDQ(0,0,2)
report(fit2)
gg_arma(fit2)
fit2 %>% my_tsresiduals()
# Forecast
forecast_2 =  forecast(fit2, h=10)
# PLot forecast
#forecast %>% autoplot(df_demanda_train)
forecast_2 %>% autoplot(df_demanda%>% filter(date >= "2020-01-01"))
# Residuals
mape(df_demanda_test$energy, forecast_2$energy)
mape(forecast_2$energy, df_demanda_test$energy)
accuracy(forecast_2$energy, df_demanda_test$energy)
# Residuals
mape(forecast_2$energy, df_demanda_test$energy)
accuracy(forecast_2$energy, df_demanda_test$energy)
# Ajuste 3
# Primero probamos con un modelo sin ajustar, automático:
fit3 <- df_demanda_train %>%
model(arima = ARIMA(energy))
# Vemos que ajusta un modelo ARIMA(2,0,3)(1,1,0)[7]. Es decir, detecta bien la estacionalidad semanal.
report(fit3)
gg_arma(fit3)
#Si visualizamos los residuos, vemos que aún hay picos que hacen que no sea ruido blanco todavía y un pico en el ACF en el retardo 14.
fit3 %>% my_tsresiduals()
# Forecast
forecast_3 =  forecast(fit3, h=10)
# PLot forecast
#forecast %>% autoplot(df_demanda_train)
forecast_3 %>% autoplot(df_demanda%>% filter(date >= "2020-01-01"))
# Residuals
#mape(df_demanda_test$energy, forecast_3$energy)
accuracy(forecast_3$energy, df_demanda_test$energy)
# Residuals
mape(df_demanda_test$energy, forecast_3$energy)
accuracy(forecast_3, df_demanda_test)
fit_prueba <- df_demanda_train %>%
model(
ets = ETS(energy),
arima = ARIMA(energy),
snaive = SNAIVE(energy))
fc <- fit_prueba %>% forecast(h = 10)
fc %>%
filter(date >= "2020-01-01") %>% autoplot(df_demanda %>% filter(date >= "2020-01-01"))
accuracy(fc, df_demanda_test)
